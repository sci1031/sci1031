# Manipulation de données vectorielles {#manip_vec}

L'objectif principal de ce module est d'apprendre à manipuler des données vectorielles. 

<br>


###### À la fin de ce module vous saurez: {-}

---

 - Ajouter de nouveaux attributs à des données vectorielles, et également supprimer ou éditer des attributs.
 - Filtrer des données vectorielles en se basant sur leurs attributs.
 - Joindre spatialement deux ensembles de données vectorielles.
 - Extraire un sous-ensemble de données pour l'intégrer aux attributs d'un second ensemble de données spatiales. 
 - Combiner, aggréger et simplifier des objets vectoriels. 
 - Transformer la géométrie d'objets vectoriels.
 - Créer des zones tampons autour d'objets vectoriels.
 - Trouver le centroid et les coordonnées d'objets vectoriels.
 - Faire des opérations topologiques sur des objets vectoriels (union, intersection, différence) 
 - Confirmer des relations topologiques entre deux objets vectoriels.
 - Calculer des mesures spatiales sur des objets vectoriels (distance, longueur, superficie).

---


<div class="boite ico librairie gauche">
###### Vous utiliserez les bibliothèques suivantes: {-}

- `sf`
- `mapview`
- `units`
</div>

<div class="boite ico fonctions gauche">
###### Vous apprendrez à utiliser les fonctions suivantes: {-}

- `subset()`
- `st_coordinates()`
- `class()`
- `merge()`
- `st_join()`
- `st_simplify()`
- `st_area()`
- `set_units()`
- `st_buffer()`
- `st_intercepts()`
- `rowSums()`
- `lengths()`
- `st_is_longlat()`
</div>

<div class="boite ico donnees gauche">
###### Vous utiliserez les données suivantes: {-}

Dans la section [leçon](#lecon_manip_vec), vous utiliserez des données vectorielles portant sur les municipalités du Québec, sur les régions administratives du Québec et sur les parcs nationaux de la Société des établissements de plein air du Québec (SÉPAQ).

Dans la section [exercices](#ex_map_vec), vous mettrez en pratique les manipulations vues dans la leçon en utilisant les mêmes données. 

</div>


## Leçon {#lecon_manip_vec}


Au [module 4](#vec), vous avez appris les fonctions essentielles pour lire et visualiser des données spatiales vectorielles sous `R`. Le présent module vous amènera maintenant à manipuler des données vectorielles. 

Dans un premier temps, cette leçon vous enseignera le fonctionnement d'opérations de base sur les données vectorielles. 
Ces opérations comprennent deux grandes catégories: les opérations qui portent sur les *attributs* des données vectorielles et les opérations qui portent sur la *géométrie* des données vectorielles. Les opérations réalisées sur les attributs des données vectorielles sont indépendantes de la composante spatiale des données, alors que les opérations spatiales prennent en considération la géométrie des données et peuvent même la transformer.

Dans un second temps, cette leçon vous guidera dans la résolution d'une problèmatique qui nécessite de manipuler des données vectorielles.  Au cours des différentes étapes permettant de résoudre la problématique, vous mettrez en pratique les diverses fonctions `R` apprises jusqu'à maintenant. Plus précisément, nous allons explorer le territoire Québécois en se posant la question suivante: 

>
> **Parmi les dix plus grandes villes du Québec, quelle est celle qui dispose du plus grand nombre de parcs nationaux dans un rayon de 70 km&nbsp;? **
>


### Télécharger les données {#data_mod7}

<div class="boite ico donnees gauche"> 

###### Les données {-} 

<br>

</div>

Dans cette leçon, nous allons utiliser les données vectorielles relatives aux [municipalités](https://www.donneesquebec.ca/recherche/fr/dataset/base-de-donnees-geographiques-et-administratives) et aux [régions administratives du Québec](https://www.donneesquebec.ca/recherche/dataset/decoupages-administratifs), ainsi qu'au réseau de la [Société des établissements de plein air du Québec](https://www.donneesquebec.ca/recherche/fr/dataset/couche-des-territoires-recreatifs-du-quebec-a-l-echelle-de-1-100-000), la SÉPAQ. 


Afin de faciliter le téléchargement de ces données, l'ensemble de ces couches d'informations spatiales peuvent être téléchargées en cliquant sur un seul lien: [données pour le module 7](https://github.com/sci1031/data/raw/master/Module7_donnees.zip). 

Sauvegardez le dossier compressé (`zip`) dans votre répertoire de travail `Module7_donnees` pour ce module, et dézippez-le. Le dossier comprend trois sous-dossiers et un fichier *.csv*:


- `villes`,
- `parcs.gdb`,
- `regions_admin`,
- `population.csv`.




### Opérations de base 


#### Importer et visualiser les données 


Commençons par charger les bibliothèques requises pour lire les données spatiales vectorielles (`sf`) et les visualiser (`mapview`). 

```{r load-libraries7, echo = TRUE, results='hide', warning = FALSE, message = FALSE}
library(sf)
library(mapview)
```


```{r, echo = FALSE, eval=TRUE}
library(leafsync)
```


<br>

Maintenant, allons lire le fichier *shapefile* de l'ensemble des municipalités du Québec en utilisant la fonction `st_read()` tel que vu dans le [module 4](#lire-shp).


```{r load-villes2}
municipalites <- st_read("Module7/Module7_donnees/villes/villes.shp")
```

<br>

Le *shapefile* a été importé dans un objet `R` de classe `sf` (c'est-à-dire un objet importé ou généré par l'utilisation de la bibliothèque `sf`). Nous remarquons que la géométrie de cet object vectoriel est de type point (`POINT`). Plus précisément, cet objet contient 767 points (*features*) et 17 attributs (*fields*).

Pour en savoir davantage sur ces attributs de nature géographique, démographique et administrative, vous pouvez télécharger et consulter la [documentation] (https://www.donneesquebec.ca/recherche/fr/dataset/base-de-donnees-geographiques-et-administratives/resource/beb4472a-0edb-4824-b67e-40e20b425326) disponible sur le site de Données Québec.  

Nous pouvons maintenant visuellement valider que l'importation des données a bien été réussie en utilisant la fonction `mapview()`&nbsp;:

```{r vis-ville, dev = 'png'}
mapview(municipalites, legend = FALSE) 
```
<br>

Dans le précédent module portant sur la [cartographie](#carto), nous avons décrit plusieurs fonctionnalités de la bibliothèque `tmap` et avons démontré sa flexibilité et à sa capacité à produire des cartes de grande qualité. Toutefois, la bibliothèque `mapview` demeure fort utile lorsque nous souhaitons visualiser rapidement des données. Par défaut, la fonction `mapview()` affiche la carte d'OpenstreeMap en arrière-pan, ce qui permet de contextualiser facilement les données. 


De plus, les cartes produites avec `mapview()` sont interactives, permettant d'accéder directement à la table d'attributs des données vectorielles représentées. Par exemple, sur la carte ci-dessus, vous n'avez qu'à cliquer sur le marqueur géographique correspondant à chaque municipalité (point) ou à chaque parc (polygone) pour obtenir la liste des attributs et leur valeur. De plus, vous pouvez choisir d'afficher l'une ou l'autre des couches en cochant la couche désirée dans la fenêtre située dans le coin supérieur gauche. 

<br>

#### Opérations sur les attributs des données vectorielles 

Les opérations sur les données vectorielles peuvent être séparées en deux grandes catégories. Les opérations qui portent sur les attributs des données et les opérations qui portent sur la géométrie des données. 

Les opérations réalisées sur les attributs des données vectorielles sont indépendantes de la composante spatiale des données. Ce sont des fonctions générales pour manipuler des bases de données et qui s'appliquent aux `data.frame` des données vectorielles. La présente section s'attarde à décrire certaines de ces fonctions. 


##### Filter des attributs {-}

Une opération fréquente lorsque nous manipulons des données vectorielles est celle de filtrer les données. Par exemple, dans le *shapefile* `municipalites` que nous venons d'importer, nous pourrions vouloir sélectionner seulement certaines municipalités parmi les 767 répertoriées ou certains attributs parmi les 17. Nous pourrions aussi vouloir déterminer quelles municipalités possédent une valeur spécifique pour un attribut donné.

Dans les sous-sections qui suivent, nous présenterons des opérations qui permettent de filtrer les attributs de données vectorielles.

<br>


###### Sélectionner des attributs à partir de leur indice {-}

Les objets `sf` sont manipulables de la même façon qu'un `data.frame` (étant eux-mêmes des `data.frame`). Les attributs correspondent aux colonnes tandis que les entités spatiales (points, lignes ou polygones) correspondent aux lignes du `data.frame`.

Par exemple, l'objet spatial `municipalites` contient `r nrow(municipalites)` points correspondant chacun à une municipalité. La table d'attributs contient quant à elle `r ncol(municipalites)` colonnes correspondant à chacun des attributs permettant de décrire les municipalités. 


Pour sélectionner un élément spatial spécifique d'un *shapefile*, nous pouvons simplement spécifier l'indice de la ligne qui lui est associée dans le `data.frame`. Par exemple :

```{r villes-ligne}
municipalites[1, ] # Pour accéder à la première ligne. 
```

<br>

Nous remarquons que le nombre de *features* (points) est maintenant de 1 (voir la première ligne de la sortie produite par `R`). En effet, puisque nous avons sélectionné le premier point de l'objet spatial `municipalites` nous avons exclu les 766 autres points. 

De la même manière, pour sélectionner un attribut spécifique, nous pouvons simplement spécifier l'indice de la colonne qui lui est associée :


```{r villes-col}
municipalites[, 2] # Pour accéder à la deuxième colonne. 
```

<br>

Nous remarquons également que le nombre de *fields* (colonnes) à diminuer à 1. 


###### Sélectionner des attributs à partir de leur nom {-}


Il est également possible de sélectionner un attribut particulier en spécifiant son nom.

Les colonnes disposent toujours d'un nom unique dans un `data.frame`. Nous pouvons afficher le nom des colonnes en utilisant la fonction `names()`&nbsp;:

```{r villes-nom}
names(municipalites)
```

<br>

Cette table contient 17 attributs. L'attribut nommé `HAP_NM_TOP` réfère au nom des municipalités. Notez que l'abréviation `TOP` signifie [toponyme](https://fr.wikipedia.org/wiki/Toponymie). 


Pour sélectionner cet attribut nous pouvons le faire simplement en utilisant son nom. Par exemple, en utilisant la syntaxe suivante :

```{r villes-col-nom}
municipalites[, "HAP_NM_TOP"]
# Ce qui revient également au même que la syntaxe suivante 
municipalites[, 13] 
# Puisque cette colonne est en treizième position.
```

<br>

Notez que la syntaxe familière `municipalites$HAP_NM_TOP` retourne un vecteur listant les valeurs de l'attribut `HAP_NM_TOP`, mais ne conserve pas la géométrie du *shapefile*:
```{r}
head(municipalites$HAP_NM_TOP)
```

<br>

Toutefois, la syntaxte précédente conserve la géométrie du *shapefile* et peut ainsi être utilisée pour définir un nouvel objet spatial. Par exemple, créons un nouveau *shapefile* qui contient seulement le nom des municipalités et leur position géographique :

```{r villes-topo-col2}
villes <- municipalites[,"HAP_NM_TOP"]
villes
```

<br>

Profitons-en pour renommer l'attribut `HAP_NM_TOP` afin d'avoir un intitulé de colonne plus explicite : 

```{r col-villes}
names(villes) <- c("toponyme", "geometry")
names(villes)
```
<!-- visualiser villes et en profiter pour noter que certaines villes ne sont pas à l'intérieur des frontières du QC  -->

<br>

##### Filtrer des valeurs d'attribut {-}

On peut vouloir sélectionner un ou plusieurs éléments spatiaux d'un *shapefile* qui possèdent une valeur spécifique d'attribut. Cette opération peut être réalisée en utilisant les fonctions `subset()` ou `which()`.


###### Fonction `subset()` {.unnumbered #fct_subset}

La fonction `subset()` n'est pas spécifique aux données spatiales, c'est une fonction générale de `R` qui retourne le sous-ensemble d'un vecteur, d'une matrice or d'un tableau de données qui satisfait une condition donnée. 

Par exemple, nous pouvons utiliser la  fonction `subset()` pour filtrer le jeu de données `villes` afin d'obtenir la localisation d'une municipalité précise:

```{r viz-villes}
la_poc <- subset(villes, toponyme == "La Pocatière")
mapview(la_poc, legend = FALSE)
```

<br>

Notez que l'objet retourné, ici `la_poc`, est de même classe que l'objet filtré, ici `villes`. Nous pouvons valider la classe d'un objet dans `R` avec la fonction `class()`. 

```{r ex-class}
class(la_poc)
```

<br>


###### Fonction `which()` {.unnumbered #fct_which}

La fonction `which()` est aussi une fonction générale de `R`. Elle identifie la position des éléments de valeur `TRUE` dans un vecteur logique. Par exemple: 

```{r which}
#Exemple 1
which(c(TRUE, FALSE, TRUE, FALSE, TRUE))

#Exemple 2
which(c(1, 1, 2) == 2)
```

<br>

Maintenant, utilisons la fonction `which()` pour isoler la ville de La Pocatière:
```{r}
which(villes$toponyme == "La Pocatière")
```

<br>

Remarquez que la fonction `which()` retourne l'**indice** de la ligne dans la table d'attributs de l'objet `villes` satisfaisant la condition `toponyme == "La Pocatière"`. 

Nous pouvons ensuite consigner cet identifiant dans l'objet `id_la_poc` et l'utiliser pour déterminer la localisation de la ville de La Pocatière:

```{r interceptions-buffer-parcs4}
id_la_poc <- which(villes$toponyme == "La Pocatière")
villes[id_la_poc,]   
```

##### Ajouter des attributs {-}

Un autre type de manipulations fréquemment utilisé est celui d'enrichir un jeu de données vectorielles en lui ajoutant des attributs. Ces nouvelles informations peuvent provenir d'une base de données non-spatiales ou d'un autre *shapefile*.


Dans le cas de données non-spatiales, nous pouvons combiner les attributs désirés en utilisant l'opération `merge()` que nous définissons dans cette sous-section. Lorsque nous souhaitons ajouter des attributs provenant de données spatiales, nous devons faire une jointure spatiale en utilisant l'opération `st_join()`. Nous définirons `st_join()` dans la section suivante portant sur les [opérations spatiales sur les données vectorielles](#fct_join).


###### La fonction `merge()` {.unnumbered #fct_merge}


La fonction `merge()` est une fonction générale de `R` qui sert à combiner deux tableaux de données différents en se servant de rangées ou de colonnes communes. 

Par exemple, ajoutons à chacune des municipilatés contenues dans le *shapefile* `villes` la taille de sa population. Cette information est contenue dans un fichier `csv` (`Module7_donnees/ville/population.csv`) et provient du [répertoire des municipalités du Québec](https://www.donneesquebec.ca/recherche/fr/dataset/repertoire-des-municipalites-du-quebec/resource/19385b4e-5503-4330-9e59-f998f5918363). 

Nous allons d'abord importer ce fichier CSV dans `R` en utilisant la fonction `read.csv()`. Ensuite, nous sélectionnerons les colonnes pertinentes de ce tableau, et nous ajouterons ces informations aux attributs de l'objet spatial `villes`. 

```{r}
pop <- read.csv("Module7/Module7_donnees/villes/population.csv",encoding="UTF-8")
```

<br>

Notez que la précision de l'encodage assure que les accents français sont bien importés lors de la lecture du document.

L'objet `pop` est un `data.frame` de `r ncol(pop)` colonnes décrivant un ensemble d'informations propres aux municipalités du Québec allant de leur nom jusqu'à la composition de leur conseil municipal. Toutes ces informations ne sont pas pertinentes pour le présent exercice. Pour faciliter la manipulation de ce tableau, sélectionnons seulement les colonnes suivantes:

- `munnom`: Nom de la ville. 
- `msuperf`: Superficie de la municipalité.
- `mpopul`: Taille de la population de la municipalité.

```{r select-pop-cols}
pop <- pop[, c("munnom", "msuperf", "mpopul")]
```

<br>

Le nouvel objet `pop` ainsi défini, contient seulement `r ncol(pop)` colonnes.

Nous voulons à présent fusionner l'objet `pop` avec l'objet spatial `villes` en utilisant la fonction `merge()`. Cette fusion entre les deux objets `villes` et `pop` sera réalisée sur les colonnes `toponyme` et `munnom` respectivement. Ces deux colonnes contiennent le nom des municipalités et agissent donc comme dénominateur commun entre les deux jeux de données. 


```{r}
#villes_qc <- merge(x = villes_qc, y = pop, by.x="toponyme", by.y="munnom",  all.x = TRUE)
villes_pop <- merge(x = villes, y = pop, by.x="toponyme", by.y="munnom")
villes_pop
``` 

<br>

Le nouveau *shapefile* `villes_pop` contient les mêmes attributs que `villes` auxquels se sont ajoutés les attributs de `pop`. 

Remarquez que `villes_pop` contient moins d'éléments que `villes`. En effet, la fonction `merge()` n'a retenue que les villes qui étaient contenues à la fois dans le *shapefile* `villes` et dans la base de données `pop`. Pour conserver l'entièreté des éléments initialement présents dans `villes`, il faudrait ajouter l'argument `all.x = TRUE` à la fonction `merge()`. Dans ce cas, les villes dont la population n'est pas définie dans `pop` se verraient attribuer une valeur `NA` à l'attribut `mpopul`.


Renommons les colonnes de `villes_pop` pour qu'elles portent un nom plus représentatif de leur contenu. 

```{r}
names(villes_pop)
names(villes_pop)[2:3] <- c("superficie", "population")
names(villes_pop) 
```


#### Opérations spatiales sur les données vectorielles 

Les opérations réalisées dans la section précédente sur les attributs des données vectorielles, telles `merge()`, `which()` et `subset()`, sont indépendantes de la composante spatiale des données. Si nous changions la géométrie des objets spatiaux décrits par les données vectorielles (par exemple en changeant les coordonnées des villes), ces opérations produiraient les mêmes résultats. Ce sont des fonctions générales pour manipuler des bases de données et qui s'appliquent aux `data.frame` des données vectorielles. 

Dans la présente section, nous verrons plutôt des opérations qui dépendent de la composante spatiale des données vectorielles. Ces opérations prennent en considération la géométrie des données et certaines peuvent aussi la transformer. 


##### Jointure spatiale {-}

Une opération de jointure permet de lier entre eux des éléments spatiaux sur la base d'une valeur d'attribut commune.


###### La fonction `st_join()`{#fct_join} {-}

La fonction `st_join()` de la bibliothèque `sf` permet de joindre à un *shapefile* de l'information provenant d'une autre couche spatiale. Cette opération constitue une jointure spatiale.

Par exemple, importons le *shapefile* des régions administratives du Québec, disponible dans le dossier `Module7_données`, et réalisons une jointure entre cette couche et la couche `villes`.

```{r}
regions <- st_read("Module7/Module7_donnees/regions_admin/regions_admin.shp")
```

<br>

```{r}
# on observe le contenu de ce shaphefile
regions

# on le visualise
mapview(regions)
```

<br>

Notez que les éléments de `regions` sont des polygones. Ces polygones possèdent un seul attribut, `"Rgns_Ad"`, correspondant au nom des régions administratives que ceux-ci délimitent. 

Nous allons maintenant faire une jointure spatiale entre `villes` et `regions` afin d'associer à chaque municipalité sa région administrative d'attache.

```{r, warning = FALSE}
villes_reg = st_join(villes, regions[ ,"Rgns_Ad"])
villes_reg
```

<br>

Remarquez que l'objet `villes_reg` est identique à l'objet `villes` mais contient un attribut supplémentaire: la colonne `Rgns_Ad`.

Il est important de préciser que la fonction `st_join()` nécessite que les deux couches spatiales à joindre utilisent le même système de coordonnées de référence (SCR).

Contrairement à la fonction `merge()` vue plus haut, la fonction `st_join()` est bien une opération spatiale. En effet, `st_join(x,y)` détermine s'il y a une intersection spatiale entre chaque élément de l'objet de gauche (`x = villes`) et l'un ou l'autre des éléments de l'objet de droite (`y = regions`). Une intersection entre deux éléments spatiaux se produit lorsqu'ils partagent une même portion de l'espace. Ainsi, il y a une intersection entre le point associé à la ville de Shawinigan et le polygone associé à la région de la Mauricie. Par ailleurs, il n'y a pas d'intersection entre le point associé à la ville de Sherbrooke et le polygone de la Mauricie.

Lorsque `st_join(x,y)` identifie la présence d'une intersection entre deux éléments, elle assigne à l'élément de gauche la valeur de l'attribut (ici `"Rgns_Ad"`) de l'élément de droite. 

Lorsqu'il n'y a pas d'intersection entre deux éléments, la fonction assigne une valeur d'attribut `NA` à l'élément de gauche. Par exemple, les données `villes` contiennent des municipalités qui ne sont pas situées au Québec. On retrouve entre autres la ville d'Albany dans l'état de New York aux États-Unis. Ainsi aucune région n'a pu être associée à ces villes.

```{r}
villes_reg[692,]
```

<br>

Si nous souhaitons que la fonction `st_join(x,y)` conserve seulement les éléments de `x` qui intersectent un ou l'autre des éléments de `y`, nous devons ajouter l'argument `left = FALSE` :

```{r, warning = FALSE}
villes_reg <- st_join(villes, regions[ ,"Rgns_Ad"], left = FALSE)
```

<br>

Visualisons le nouveau *shapefile* que nous venons de créer. Ce dernier contient seulement les municipalités à l'intérieur du territoire québécois.

```{r,  warning = FALSE, dev = 'png'}
mapview(villes_reg, legend = FALSE)
```

<br>

Notez que lorsque vous cliquez sur les points de la carte, la valeur de l'attribut  "Rngs_Ad" est maintenant également donnée.

Vous pouvez ainsi différencier visuellement les municipalités selon leur région administrative d'attache.
```{r,  warning = FALSE, dev = 'png'}
mapview(villes_reg, zcol = "Rgns_Ad", legend = FALSE)
```

<br>

Que se produit-il si nous inversons les arguments `villes` et `regions` dans la fonction `st-join()` &nbsp;? Dans ce cas, la jointure spatiale associe à chaque région les villes qui sont situées (c'est-à-dire intersectent) son territoire. Observons le résultat d'une telle jointure&nbsp;:

```{r, warning = FALSE}
reg_villes <- st_join(regions, villes[,"toponyme"], left = FALSE)
reg_villes
```

<br>

Le *shapefile* `reg_villes` est constitué des polygones de `regions`. Puisque plusieurs municipalités intersectent chaque région, le polygone d'une région donnée est dupliqué pour chacun des points. C'est-à-dire qu'une nouvelle ligne est ajoutée pour chacune des intersections identifiées.

Remarquez que nous pouvons aussi utiliser la fonction `join_st()` en vue de créer un filtre spatial, par exemple avec la fonction `subset()` &nbsp;:

```{r, dev = 'png'}
villes_CN<- subset(villes_reg, Rgns_Ad=="Côte-Nord")
mapview(villes_CN, legend = FALSE)
```

<br>

Cette opération nous a permis de filtrer les municipalités du Québec pour retenir seulement celles situées dans la région administrative de la Côte-Nord.



##### Opérations géométriques {-}

Les opérations géométriques sur les données vectorielles sont des opérations qui peuvent changer la géométrie des données ou qui peuvent créer, à partir de celles-ci, des nouveaux objets vectoriels de géométrie différente. 


###### La fonction `aggregate()` {-}

La fonction `aggregate()` de la bibliothèque `sf` permet d'agréger (c'est-à-dire de grouper) des éléments spatiaux d'une même couche de données vectorielles. 

Afin de démontrer comment opère la fonction `aggregate()` considérons d'abord l'objet `villes_reg_pop`. Ce dernier est formé par la jointure spatiale entre `villes_pop`, le *shapefile* associant à chaque municipalité la taille de sa population, et `regions`&nbsp;:
```{r, warning = FALSE}
villes_reg_pop <- st_join(villes_pop, regions[ ,"Rgns_Ad"], left = FALSE)
villes_reg_pop
```

<br>

L'objet `villes_reg_pop` associe à chaque municipalité la taille de sa population ainsi que sa région administrative. 
En agrégeant ensemble les villes d'une même région, il nous est possible de déterminer la taille de la population de cette région. C'est ce que nous allons faire en utilisant la fonction `aggregate()`&nbsp;:


```{r, warning = FALSE}
reg_pop<-aggregate(villes_reg_pop["population"], by = list(villes_reg_pop$Rgns_Ad), FUN = sum, na.rm = TRUE)
reg_pop
```

<br>

De façon générale, la fonction `aggregate(x, by, FUN)` comprend trois arguments:

- `x` est l'objet spatial que l'on souhaite agréger,
- `by` défini la condition utilisée pour regrouper les éléments de `x`,
- `FUN` défini la fonction selon laquelle l'attribut d'un groupement est calculé à partir des attributs des éléments agrégés.

Dans notre exemple, nous avons regroupé les points de l'objet spatial `villes_reg_pop["population"]` qui possèdent la même valeur d'attribut `"Rgns_Ad"`. Les points ainsi regroupés forment une géométrie multipoint (`MULTIPOINT`). Chaque groupe de points est identifié par le nom de sa région administrative (Abitibi-Témiscamingue, Bas-Saint-Laurent, etc.). L'attribut d'un groupe est calculé en faisant la somme (`FUN = sum`) des attributs des points qui le constituent. L'argument additionnel `na.rm = TRUE` précise que lors du calcul de la somme, les éléments dont l'attribut `"population"` prend la valeur `NA` doivent être ignorés. En effet, la population de quelques municipalités n'est pas définie dans cette base de données. Notez qu'une autre fonction aurait pu être utilisée, par exemple la moyenne, le maximum, le minimum, etc.

La condition `by` peut prendre différentes forment. Elle peut être définie par une liste de longueur égale au nombre d'éléments dans `x` (c'est-à-dire le même nombre de rangées). C'est de cette façon que nous l'avons définie plus haut (la liste est de longueur égale aux nombres de points dans `villes_reg_pop`). De plus, `by` peut prendre la forme d'un objet spatial dont la géométrie est utilisée pour grouper les éléments de `x`. Dans ce cas, la géométrie du nouvel objet créé par la fonction `aggregate()` est la même que l'objet `by`.


Donnons un exemple illustrant cette situation. Agrégeons maintenant les municipalités de l'objet `villes_pop["population"]` en utilisant directement l'objet `regions` constitué de polygones &nbsp;: 

```{r, warning = FALSE}
reg_pop2 <-aggregate(villes_pop["population"], by = regions, FUN = sum, na.rm = TRUE)
reg_pop2
```

<br>

Observez que les groupements sont maintenant des polygones, et non des multipoints. Par ailleurs le calcul de l'attribut `"population"` est le même. 

Une visualisation du nouvel objet `reg_pop2` permet d'illustrer les régions selon la taille de leur population&nbsp;:
```{r, dev = 'png'}
mapview(reg_pop2)
```

<br>

Donnons un dernier exemple de l'utilisation de la fonction `aggregate()` en considérant le *shapefile* régions

```{r}
regions
```

<br>

Remarquez que certaines régions, comme la Côte-Nord, sont représentées par plusieurs polygones. C'est pour cette raison que ce *shapefile* contient 21 éléments spatiaux alors qu'il y a 17 régions administratives au Québec.

Utilisons la fonction `aggregate()` pour agréger en un seul multipolygone les polygones qui portent la même valeur d'attribut `"Rgns_Ad"`&nbsp;: 

```{r}
regions_agg <-aggregate(regions, by=list(regions$Rgns_Ad), unique)
regions_agg
```

<br>

Cette fois nous avons utilisé la fonction `unique` pour agréger les attributs qui sont de classe caractère. Remarquez que la Côte-Nord est maintenant représentée par un multipolygone (`MULTIPOLYGON`) et que le nouveau *shapefile* `regions_agg` contient 17 éléments, un pour chacune des régions administratives.

Retirons la première colonne superflue de ce nouveau *shapefile* et utilisons-le dans les futurs exemples pour désigner les régions administratives. 
```{r}
regions <- regions_agg[-1]  #pour retirer la première ligne
```

<br>

###### La fonction `st_simplify()` {.unnumbered #fct_simplify}

Il est parfois utile de simplifier les objets vectoriels de types ligne ou polygone afin de produire des cartes à des échelles plus petites. La simplification permet de réduire l'utilisation de la mémoire, du disque, et de la bande passante. 

La fonction `st_simplify()` de la bibliothèque `sf` permet de simplifier des objets vectoriels de types ligne ou polygone en réduisant le nombre de points que ceux-ci comprennent. Souvenez-vous qu'une ligne est constituée d'une succession de points et qu'un polygone est constitué d'un ensemble de lignes. 

Cette fonction est basée sur l'algorithme de [Douglas-Peucker](https://fr.wikipedia.org/wiki/Algorithme_de_Douglas-Peucker). Décrire le fonctionnement de cet algorithme dépasse l'objectif de ce cours. Grosso modo, l'algorithme fait appel à un seuil de distance (le paramètre `dTolerance`) qu'il utilise pour transformer en ligne droite toute courbe qui dévie d'une ligne droite par une quantité moindre que ce seuil. Cette distance réflète en quelque sorte la résolution que nous souhaitons atteindre avec l'objet simplifié.

Le seuil de tolérance étant une distance, nous l'exprimons en mètres. Nous devons alors nous assurer que l'objet spatial à simplifier est dans un système de coordonnées métriques.

En guise d'exemple, simplifions le *shapefile* des régions administratives du Québec (\@ref(fig:ex-st-simple)):

```{r, warning = FALSE }
regions_nad <- st_transform(regions, crs = 32198)
regions_simple_10 <- st_simplify(regions_nad, dTolerance = 10000) #10000m
regions_simple_40 <- st_simplify(regions_nad, dTolerance = 40000) #40000m
```


```{r ex-st-simple, echo = FALSE, warning = FALSE, fig.align = 'left', out.width = '100%', dev = 'png', fig.cap="La carte des régions administratives du Québec. Polygones originaux (à gauche) et polygones simplifiés avec un seuil faible (au centre) et un seuil élevé (à droite)."}
map <- mapview(regions_nad, col.regions = "blue", alpha.regions = 0.4, legend = FALSE)
map_10 <- mapview(regions_simple_10, col.regions = "blue", alpha.regions = 0.4, legend = FALSE)
map_40 <- mapview(regions_simple_40, col.regions = "blue", alpha.regions = 0.4,legend = FALSE)

M <- leafsync::latticeView(map,map_10, map_40, ncol = 3)
M
```
<br>

Remarquez que nous avons d'abord transformé l'objet spatial `regions` dans le système de coordonnées de référence NAD83, dont le EPSG correspond à 32198, puisque l'unité de ce système est le mètre.


###### La fonction `st_combine()` {.unnumbered #fct_combine}

La fonction `st_combine()` de la bibliothèque `sf` sert à combiner des géométries afin d'en former une seule. Cette opération peut être utile lorsque nous souhaitons considérer plusieurs géométries comme formant un même objet spatial.

```{r, warning=FALSE, echo=FALSE, eval=TRUE}

reg_tourist <- st_read("Module7/data/regions_touristiques/Shapefile/regn_tours_s250k_20160125.shp")

#reg_tourist
iles<-subset(reg_tourist, Nom_reg_to =="Îles-de-la-Madeleine")
gasp<-subset(reg_tourist, Nom_reg_to =="Gaspésie")
#mapview(iles, col.regions = "green", alpha.regions = 0.4) + mapview(gasp, col.regions = "blue", alpha.regions = 0.4)

GIM <-iles
GIM[2,]<-gasp
GIM <-GIM[,-4]
GIM <-GIM[,-2]
names(GIM)<-c("Id", "Nom_reg", "geometry")

#GIM
#mapview(GIM, zcol = "Nom_reg")

# iles_poly<-st_cast(iles, to = "POLYGON")
# iles_poly
# mapview(iles_poly)
```
<br>

Considérons le *shapefile* `GIM` contenant deux géométries: le polygone délimitant la Gaspésie et un polygone délimitant les Îles-de-la-Madeleine.

```{r}
GIM
```

Maintenant, combinons ces deux polygones pour former une géométrie unique qui correspondra à la région administrative de la Gaspésie - Îles-de-la-Madeleine


```{r}
GIM_combine <- st_combine(GIM)
GIM_combine
```
Le nouvel objet `GIM_combine` est effectivement formé d'une seule géométrie. Notez cependant que la fonction `st_combine()` ne fusionne pas les frontières à l'intérieur du nouveau polygone formé (\@ref(fig:map-combo)). Pour unir deux polygones, il faut plutôt utiliser la fonction `st_union()` que nous définirons plus bas dans cette leçon.

```{r map-combo, echo = FALSE, warning = FALSE, fig.align = 'left', out.width = '100%', dev = 'png',fig.cap="La Gaspésie et les Îles-de-la-Madeleine traitées comme deux polygones distincts (gauche), leur combinaison par la fonction `st_combine()` (centre), et leur union par la fonction `st_union()` (droite)."}
GIM_union<-st_union(iles, gasp)
GIM_combine<-st_sf(GIM_combine)#sinon la legende n'apparait aps
map_GIM <- mapview(GIM, zcol = "Nom_reg")
map_GIM_union <-mapview(GIM_union,  col.regions = "green", alpha.regions = 0.2)
map_GIM_combo <- mapview(GIM_combine, col.regions = "blue", alpha.regions = 0.2)
M <- leafsync::latticeView(map_GIM,map_GIM_combo, map_GIM_union, ncol = 3)


M
```

<br>

<!--  La classe est aussi changée
En fait, on dirait que non: je retire?

```{r}
class(GIM)
class(GIM_combine)
class(GIM_union)
```

-->


###### La fonction `st_cast()` {.unnumbered #fct_cast}

La fonction `st_cast()` sert à convertir la géométrie d'un objet spatial donné vers une autre géométrie. Cette fonction comprend deux arguments : `st_cast(x, to)`. Le premier argument, `x`, correspond à l'objet vectoriel dont on souhaite modifier la géométrie, alors que le second argument, `to`, correspond à la géométrie que l'on souhaite lui attribuer. 

Donnons un exemple. Utilisons d'abord le *shapefile* `regions` pour isoler le polygone de la région administrative de la Mauricie grâce à la fonction `subset()`&nbsp;:
```{r, warning=FALSE}
Mauricie <- subset(regions,Rgns_Ad=="Mauricie")
Mauricie
```

<br>

Nous observons que l'objet `Mauricie` est bel et bien de type *polygone*. Maintenant utilisons la fonction `st_cast()` pour transformer la géométrie de cet objet en type *multiligne* et *multipoint*  &nbsp;:

```{r, warning=FALSE}
Mauricie_lines <- st_cast(Mauricie, to = "MULTILINESTRING")
Mauricie_lines
```
```{r, warning=FALSE}
Mauricie_pts<-st_cast(Mauricie, to = "MULTIPOINT")
Mauricie_pts
```

<br>

Nous observons que les deux nouveaux objets vectoriels ont bel et bien la géométrie souhaitée (\@ref(fig:ex-cast1)).

```{r ex-cast1, echo = FALSE, warning = FALSE, fig.align = 'left', out.width = '100%', dev = 'png',fig.cap="La fonction `st_cast()` a été utilisée pour transformer le polygone de la Mauricie (gauche) en multilignes (centre) et en multipoints (droite)."}

Lines<- mapview(Mauricie_lines, legend = FALSE)
Poly <- mapview(Mauricie, legend = FALSE)
Points<-mapview(Mauricie_pts, legend = FALSE)

# Visualisons les trois cartes côte à côte
M <- leafsync::latticeView(Poly@map,Lines@map,Points@map, ncol = 3)
M

```

<br>


Dans cet exemple, nous avons en quelque sorte "décomposé" la géométrie d'un polygone en lignes puis en points. Or, la fonction `st_cast()` peut également servir à "consolider" des géométries.

En guise d'exemple, considérons l'objet `villes_NQ_combo` créé en isolant du *shapefile* `villes_reg` les villes situées dans la région administrative du Nord-du-Québec et en les combinant par l'utilisation de la fonction `st_combine()`&nbsp;:

```{r}
villes_NQ <- subset(villes_reg, Rgns_Ad == "Nord-du-Québec") 
villes_NQ_combo <- st_combine(villes_NQ)
villes_NQ_combo
```

<br>

Cet objet possède une géométrie multipoint où chaque point correspond à une municipalité du Nord-du-Québec.

Utilisons maintenant la fonction `st_cast()` pour transformer la géométrie de cet objet en ligne et en polygone &nbsp;:

```{r}
villes_NQ_lines<-st_cast(villes_NQ_combo, to = "LINESTRING")
villes_NQ_lines


villes_NQ_pol<-st_cast(villes_NQ_combo, to = "POLYGON")
villes_NQ_pol
```

<br>

```{r ex-cast2, echo = FALSE, warning = FALSE, fig.align = 'left', out.width = '100%', dev = 'png',fig.cap="La fonction `st_cast()` a été utilisée pour transformer les villes du Nord-du-Québec de multipoints (gauche) en ligne (centre) et en polygone (droite)."}

Points <- mapview(villes_NQ_combo, legend = FALSE)
Lines <- mapview(villes_NQ_lines, legend = FALSE)
Pol <- mapview(villes_NQ_pol, legend = FALSE)

M <- leafsync::latticeView(Points,Lines,Pol, ncol = 3)
M

```

<br>

L'objet `villes_NQ_lines` correspond effectivement à un ensemble de lignes et l'objet `villes_NQ_lines` à un ensemble de polygones formés en reliant les points ensembles.


###### La fonction `st_buffer()` {-}

Une zone tampon (appelée *buffer* en anglais) est un polygone dont les frontières sont définies par une distance donnée autour d'un objet vectoriel. Une zone tampon peut être créée autour de tout objet vectoriel, que ce soit des points, des lignes ou des polygones. 

La création de zones tampons est généralement réalisée pour répondre à des questions de nature géographique. Par exemple, combien de garderies se situent à une distance de 2&nbsp;km de ma maison&nbsp;? Ou encore, combien de stations services se situent à moins de 500&nbsp;m de la route menant de Chelsey à Cantley en Outaouais&nbsp;? 

La fonction `st_buffer()` de la bibliothèque `sf` permet de créer des zones tampons. Cette fonction comprend obligatoirement deux arguments. Le premier correspond à l'objet vectoriel autour du quel nous souhaitons construire une zone tampon, et le deuxième argument défini la distance sur laquelle la zone tampon s'étendra autour de l'objet vectoriel. Comme pour la fonction `st_simplify()`, l'objet vectoriel auquel nous appliquons la fonction `st_buffer()` doit être exprimé dans un SCR d'unité de mesure métrique.

Construisons des zones tampons autour de la ville de La Pocatière, que nous avons isolée plus haut, en considérant deux distances différentes (\@ref(fig:buffer-lapoc)):

```{r}
la_poc_nad <- st_transform(la_poc, crs = 32198)
la_poc_tampon10 <- st_buffer(la_poc_nad, dist = 10e3)
la_poc_tampon50 <- st_buffer(la_poc_nad, dist = 50e3)
```

<br>

Notez que l'expression `e3` correspond au chiffre 1000 (c'est-à-dire 10 exposent 3).

```{r buffer-lapoc, echo = FALSE, warning = FALSE, fig.align = 'left', out.width = '100%', dev = 'png',fig.cap="Deux zones tampons de 10 km (en bleu) et de 50 km (en vert) autour de la ville de La Pocatière"}
# library(tmap)
# new_bb <- bb(regions_nad, xlim = c(0.25, 0.75), ylim = c(0.25, 0.75), relative = TRUE)
# mapQ <- tm_shape(regions_nad, bbox = new_bb) + tm_fill()
# mapdot <- tm_shape(la_poc_nad) + tm_dots(col="black")
# map1 <- mapQ + mapdot + tm_layout(outer.margins = c(0.3, 0.3, 0.3, 0.3)) + 
#  tm_shape(la_poc_tampon10) + tm_fill(col="blue", alpha = 0.4) + tm_borders(col="blue")
# map2<- mapQ + mapdot + tm_layout(inner.margins = c(0.3, 0.3, 0.3, 0.3)) +
#   tm_shape(la_poc_tampon50) + tm_fill(col="green", alpha = 0.4) + tm_borders(col="green")
# 
# 
# tmap_arrange(map1,map2)
M <- mapview(la_poc_tampon50, col.regions = "green", alpha.regions = 0.2, legend = FALSE) + mapview(la_poc_tampon10, col.regions = "blue", alpha.regions = 0.4,  legend = FALSE)

M@map

```

<br>


Maintenant, construisons des zones tampons autour des régions administratives de l'Abitibi-Témiscamingue et du Saguenay - Lac-Saint-Jean (\@ref(fig:buffer-regions)). Utilisons d'abord la fonction `subset()` pour isoler les polygones correspondants à ces régions à partir du *shapefile* `regions_nad` dont l'unité de mesure du SCR est le mètre. 


```{r}
# Isoler les polygones des deux régions
Abitibi <- subset(regions_nad, Rgns_Ad == "Abitibi-Témiscamingue")
SagStJean <- subset(regions_nad, Rgns_Ad == "Saguenay - Lac-Saint-Jean")

# Calculer une zone tampon pour chacun des polygones
Abitibi_tampon20 <- st_buffer(Abitibi, dist = 20e3)  #20 km
SagStJean_tampon50 <- st_buffer(SagStJean, dist = 70e3)  #70 km
```

<br>

```{r buffer-regions, echo = FALSE, warning = FALSE, fig.align = 'left', out.width = '100%', dev = 'png',fig.cap="Une zone tampon de 20 km autour de la région administrative de l'Abitibi-Témicamingue et une zone tampon de 70 km autour du Saguenay - Lac-Saint-Jean."}
M <- mapview(SagStJean_tampon50, col.regions = "green", alpha.regions = 0.2, legend = FALSE) +
mapview(SagStJean, col.regions = "green", alpha.regions = 0.4, legend = FALSE) + 
mapview(Abitibi_tampon20, col.regions = "blue", alpha.regions = 0.2,  legend = FALSE) +
mapview(Abitibi, col.regions = "blue", alpha.regions = 0.4,  legend = FALSE) 

M@map

```

<br>


Notez que la zone tampon d'un polygone inclue le polygone d'origine. C'est-à-dire que ce n'est pas simplement une bordure autour du polygone. 

###### La fonction `st_centroid` {-}

Le centroïde d'un polygone en cartographie correspond approximativement au centre géométrique d'un polygone^[Le centre géométrique d'une forme planaire est la moyenne des positions de tous les points constituants la forme. Vous pouvez trouver des informations supplémentaires sur le centroïde [ici]^(http://wiki.gis.com/wiki/index.php/Centroid).]. Ces coordonnées servent parfois à définir la localisation du polygone. La fonction `st_centroid()` de la bibliothèque `sf` permet de calculer le centroïde de polygones.

Déterminons le centroïde des polygones de l'Abitibi et du Saguenay - Lac-Saint-Jean (\@ref(fig:centroid-regions)). Notez que la fonction `st_centroid()` nécessite également que le polygone soit défini selon un SCR dont l'unité de mesure est le mètre.

```{r, warning=FALSE}
centre_Abitibi <- st_centroid(Abitibi)
centre_Abitibi
centre_SagStJean <- st_centroid(SagStJean)
centre_SagStJean
```

<br>

La fonction `st_centroid()` retourne un objet vectoriel de type point qui conserve les attributs du polygone.

```{r centroid-regions, echo = FALSE, warning = FALSE, fig.align = 'left', out.width = '100%', dev = 'png',fig.cap="Les centroïdes (en rouge) des régions de l'Abitibi-Témicamingue (en bleu) et du Saguenay - Lac-Saint-Jean (vert) calculés avec la fonction  `st_centroid()`."}
M <- mapview(centre_SagStJean, col.regions = "red", legend = FALSE) +
mapview(SagStJean, col.regions = "green", alpha.regions = 0.4, legend = FALSE) + 
mapview(centre_Abitibi, col.regions = "red" ,legend = FALSE) +
mapview(Abitibi, col.regions = "blue", alpha.regions = 0.4,  legend = FALSE) 

M@map

```

<br>


###### La fonction `st_coordinates` {-}


La fonction `st_coordinates()` permet de connaître les coordonnées d'un objet vectoriel. Trouvons, par exemple, les coordonnées de la ville de La Pocatière que nous avons isolée plus haut &nbsp;: 


```{r ex-coordinates}
st_coordinates(la_poc)
```

<br>

Dans le cas présent, les coordonnées sont exprimées en *degrés*. Le `X` correspond à la longitude et le `Y`, à la latitude. En effet, le SCR de `la_poc` utilise des longitudes-latitudes. Ceci peut-être confirmé en utilisant la fonction `st_is_longlat()` &nbsp;: 

```{r}
st_is_longlat(la_poc)
```

<br>

D'autre part, l'objet `la_poc_nad`, que nous avons obtenu en transformant `la_poc` dans le SCR NAD83 utilise plutôt des mètres. Ainsi &nbsp;: 


```{r}
st_is_longlat(la_poc_nad)
```

<br>

Conséquemment, les coordonnées identifiées par la fonction `st_coordinates()` sont en mètres &nbsp;: 
```{r}
st_coordinates(la_poc_nad)
```

<br>

Notez que cette fonction peut être utilisée sur tout objet de type vectoriel (ligne, multiligne, polygone, etc.). La sortie correspondra alors à un tableau donnant les coordonnées de chaque point consituant l'objet. 



######  Opérations topologiques entre deux couches {-}


Les opérations topologiques décrivent les relations spatiales entre des objets^[https://geocompr.robinlovelace.net/spatial-operations.html#topological-relations].
Ces opérations sont équivalentes aux opérations ensemblistes en mathématiques, telles l'union ou l'intersection, mais s'appliquent cette fois à des objets définis par une géométrie. 

La bibliothèque `sf` contient plusieurs opérateurs topologiques; par exemple: `st_union()`, `st_intersection()`, `st_difference()` et `st_sym_difference()`. Ces opérateurs forment un nouvel objet spatial à partir des deux objets spatiaux intérroger. Par exemple, la géométrie de l'objet `z` formé par l'opération `z <- st_union(x,y)` est constituée de la géométrie de `x` *et* de celle de `y` sans toutefois qu'il y ait de chevauchement.

Pour illustrer les opérations topologiques entre deux objets vectoriels considérons les polygones A et B créés en définissant des zones tampons à partir des polygones de l'Abitibi-Témiscamingue et du Saguenay - Lac-Saint-Jean respectivement. 

```{r}
A <- st_buffer(Abitibi, dist = 80e3)
B <- st_buffer(SagStJean, dist = 100e3)
```

<br>

```{r, warning = FALSE, echo = FALSE, eval = TRUE}
A$Rgns_Ad<-"A"
B$Rgns_Ad<-"B"
```

<br>

Calculons maintenant des opérations topologiques sur ces polygones &nbsp;: 

```{r, warning = FALSE}
union_AB <- st_union(A,B)
inter_AB <- st_intersection(A,B)
diff_AB <- st_difference(A,B)
diff_BA <- st_difference(B,A)
sym_diff_AB <- st_sym_difference(A,B)
```

<br>

Observons les géométries produites par ces opérations (figure \@ref(fig:topo-op)) &nbsp;:

```{r topo-op, echo = FALSE, warning = FALSE, fig.align = 'left', out.width = '100%', dev = 'png',fig.cap="Exemples d'opérations topologiques sur les polygones A et B. En haut: illustrations de A et B (gauche) et de `st_union(A,B)` (droite). Au centre:   illustrations de `st_difference(A,B)` (gauche) et de `st_difference(B,A)` (droite). En bas: illustrations de `st_intersection(A,B)` (gauche) et de `st_sym_difference(A,B)` (droite)."}
map_AB <- mapview(A, col.regions = "blue", alpha.regions = 0.2)+mapview(B, col.regions = "red", alpha.regions = 0.2)
map_union <- mapview(union_AB, col.regions = "darkmagenta", alpha.regions = 0.2)
map_inter <- mapview(union_AB, col.regions = "grey", alpha.regions = 0.2, legend = FALSE) + mapview(inter_AB, col.regions = "darkmagenta", alpha.regions = 0.2)
map_diffAB <- mapview(union_AB, col.regions = "grey", alpha.regions = 0.2, legend = FALSE) + mapview(diff_AB, col.regions = "darkmagenta", alpha.regions = 0.2)
map_diffBA <- mapview(union_AB, col.regions = "grey", alpha.regions = 0.2, legend = FALSE) + mapview(diff_BA, col.regions = "darkmagenta", alpha.regions = 0.2)
map_symdiff <- mapview(union_AB, col.regions = "grey", alpha.regions = 0.2, legend = FALSE) + mapview(sym_diff_AB, col.regions = "darkmagenta", alpha.regions = 0.2)

M <- leafsync::latticeView(map_AB, map_union,map_diffAB, map_diffBA, map_inter, map_symdiff, ncol = 2)

M
```

<br>


###### Opérations topologiques de confirmation {-}

Les opérations topologiques de confirmation sont des fonctions qui permettent de vérifier si deux objets spatiaux satisfont à une relation topologique donnée. Ces opérations ne créent pas un nouvel objet spatial, elles retournent plutôt une valeur binaire qui confirme si oui ou non la relation existe entre les deux objets interrogés. 

La bibliothèque `sf` contient plusieurs opérateurs topologiques de confirmation; par exemple: `st_intersects()`, `st_disjoint()`, `st_crosses()`, `st_overlaps()`, `st_touches()`, `st_within()` et `st_contains()`.


####### La fonction `st_intersects` {.unnumbered #fct_intersects}


La fonction `st_intersects()` vérifie si deux objets spatiaux `X` et `Y` occupent un espace commun. La fonction confirmera qu'il y a bel et bien une intersection entre les deux objets si leurs intérieurs ou leurs frontières se recoupent. `X` et `Y` peuvent avoir n'importe quelle géométrie (point, multipoint, ligne, multiligne, polygone, multipolygone) (figure  \@ref(fig:st-intersects)).


```{r st-intersects, fig.align='center', echo=FALSE, fig.cap="Combinaisons de géométries satisfaisant à la condition d'intersection. Récupérer sur le site de documentation de **postgis**: http://postgis.net/workshops/postgis-intro/spatial_relationships.html", out.width = '60%'}
knitr::include_graphics('Module7/images/st_intersects.png')
```

```{r, echo = FALSE, warning=FALSE}
centre_A <- st_centroid(A)
centre_B <- st_centroid(B)
centre_unionAB <- st_centroid(union_AB)
centre_interAB <- st_centroid(inter_AB)


A_lines<-st_cast(A, to = "LINESTRING")
B_lines<-st_cast(B, to = "LINESTRING")
B_lines_A_lines_int<-st_intersection(B_lines,A_lines)
ABpoints<-st_cast(B_lines_A_lines_int, to = "POINT")
point_interAB<-ABpoints[1,]

A_points <-st_cast(A, to = "POINT")
A_sub<-A_points[1:100,]
A_sub <- st_combine(A_sub)
A_trait <-st_cast(A_sub, to = "LINESTRING", group_or_split = TRUE)
A_pp<-A_points[1,]

points<-st_centroid(A)[,"geometry"]
points[2,]<-st_centroid(B)[,"geometry"]
points[3,]<-st_centroid(inter_AB)[,"geometry"]
points[4,]<-st_centroid(union_AB)[,"geometry"]
#points[5,]<-point_interAB[,"geometry"]
points[5,]<-A_points[1,"geometry"]

colors<-c("Bleu","Rouge","Violet","Jaune","Vert")
points$couleur<-colors

point_bleu<- subset(points, couleur=="Bleu")
point_rouge<- subset(points, couleur=="Rouge")
point_violet<- subset(points, couleur=="Violet")
point_jaune<- subset(points, couleur=="Jaune")
point_vert<- subset(points, couleur=="Vert")

```


Pour bien comprendre comment opère `st_intersects()` considérons le polygone A utilisé précédemment ainsi que l'objet spatial `points` constitués de cinq points de couleur différente.

```{r}
points
```

```{r geo-conf1, warning=FALSE, echo=FALSE, fig.align='center', dev = 'png',fig.cap="Exemples illustrant la fonction `st_intersects()`.", out.width = '100%'}
map_AB <- mapview(A, col.regions = "blue", alpha.regions = 0.2, legend = FALSE) + 
  ##mapview(B, col.regions = "red", alpha.regions = 0.2, legend = FALSE) +
  mapview(point_bleu, col.regions="blue",legend = FALSE) + 
  mapview(point_rouge, col.regions="red",legend = FALSE) +
  mapview(point_violet, col.regions="darkmagenta",legend = FALSE)+
  mapview(point_jaune, col.regions="darkgoldenrod",legend = FALSE)+
  mapview(point_vert, col.regions="darkgreen",legend = FALSE)
  ##mapview(A_trait, color = "black", lwd = 3, legend = FALSE)
map_AB@map
```

<br>


Utilisons a fonction `st_intersects()` pour déterminer quels points intersectent le polygone A :

```{r, warning=FALSE}
st_intersects(points, A)
```

La sortie est exprimée sous forme d'une liste contenant 5 paires éléments; une paire pour chacun des points interrogés. Le premier élément d'une paire (c'est-dire,le chiffre avant le deux-points) correspond à l'indice du point. Le second élément prend la valeur `1` si le point intersecte le polygone A, et la valeur `empty` si le point ne recoupe pas le polygone A. 

Il est aussi possible d'ajouter l'argument `sparse = FALSE` afin que la sortie s'exprime sous une forme matricielle d'éléments logiques.

```{r}
st_intersects(points, A, sparse = FALSE)
```

<br>

La forme logique est particulièrement utile lorsque nous voulons filtrer les géométries qui satisfont à la condition d'intersection. Par exemple, cette commande retourne seulement les points qui intersectent le polygone A :
```{r}
points[st_intersects(points, A, sparse = FALSE),]
```

<br>

Que se passent-ils si nous inversons les arguments de la fonction `st_intersects()` ?
```{r}
st_intersects(A, points)
```

<br>

Dans ce cas, la fonction retourne une liste d'une seule combinaison éléments associée au polygone interrogé. Cette fois, les éléments à droite du deux-points correspondent aux indices des points qui satisfont à la condition d'intersection. 


####### La fonction `st_disjoint` {-}

La fonction `st_disjoint()` vérifie la condition inverse de la fonction `st_intersects()`, c'est-à-dire l'absence d'intersection entre deux objets `X` et `Y` (figure  \@ref(fig:st-disjoint)). 


```{r st-disjoint, fig.align='center', echo=FALSE, fig.cap="Combinaisons de géométries disjointes. Image récupérée sur le site de documentation de **postgis**: http://postgis.net/workshops/postgis-intro/spatial_relationships.html", out.width = '60%'}
knitr::include_graphics('Module7/images/st_disjoint.png')
```

Par exemple, la fonction `st_disjoint()` permet de confirmer que les points jaune et rouge sont disjoints du polygone A (Figure  \@ref(fig:geo-conf1))&nbsp;:
```{r}
st_disjoint(A, points)
# ou encore
points$couleur[st_disjoint(A, points,sparse = FALSE)]
```


####### La fonction `st_crosses` {-}

La fonction `st_crosses()` vérifie si deux objets spatiaux `X` et `Y` se croisent. Cette fonction est donc similaire à la fonction `st_intersects()` mais elle contient des conditions supplémentaires:

* l'intersection entre les deux géométries inclue une partie mais pas l'entièreté de leurs intérieurs,
* la dimension géométrique de l'intersection doit être inférieure à la dimension maximale des deux géométries, 
* l'intersection ne peut être égale à l'une ou l'autre des géométries.

La figure \@ref(fig:st-crosses) illustre différentes combinaisons de géométries qui satisfont à la condition `st_crosses`.

```{r st-crosses, fig.align='center', echo=FALSE, dev = 'png',fig.cap="Combinaisons de géométries qui se croisent. Image récupérée sur le site de documentation de **postgis**: http://postgis.net/workshops/postgis-intro/spatial_relationships.html", out.width = '60%'}
knitr::include_graphics('Module7/images/st_crosses.png')
```

Donnons quelques exemples pour démontrer en quoi la fonction `st_crosses()` diffère de la fonction  `st_intersects()`. Pour ce faire, considérons les géométries illustrées à la figure \@ref(fig:geo-conf2). 


```{r, warning=FALSE, echo=FALSE}
Abi_points <-st_cast(Abitibi, to = "POINT")
Abi_sub<-Abi_points[1600:2000,]
Abi_sub <- st_combine(Abi_sub)
Abi_trait <-st_cast(Abi_sub, to = "LINESTRING", group_or_split = TRUE)

B_points<-st_cast(B,to = "POINT")
B_sub<-B_points[337:387,]
B_sub <- st_combine(B_sub)
B_trait <-st_cast(B_sub, to = "LINESTRING", group_or_split = TRUE)

trait_noir<-A_trait
trait_bleu<-Abi_trait
trait_mauve<-B_trait
```

```{r geo-conf2, warning=FALSE, echo=FALSE, fig.align='center', dev = 'png',fig.cap="Exemples illustrant la fonction `st_crosses()`.", out.width = '100%'}
map_AB <- mapview(A, col.regions = "blue", alpha.regions = 0.2, legend = FALSE) + 
  mapview(B, col.regions = "red", alpha.regions = 0.2, legend = FALSE) +
  mapview(trait_bleu, color ="darkblue", lwd = 3, legend = FALSE)+
  mapview(trait_mauve, color = "purple", lwd = 3, legend = FALSE)
map_AB@map
```

<br>


Bien que toutes ces géométries s'intersectent, elles ne se croisent pas toutes. Vérifions d'abord la condition d'intersection &nbsp;:
```{r}
st_intersects(A,trait_bleu)
st_intersects(A,trait_mauve)
st_intersects(A,B)
```

<br>

Puis, la condition de croisement &nbsp;:
```{r}
st_crosses(A,trait_bleu)
st_crosses(A,trait_mauve)
st_crosses(A,B)
```

<br>

Le trait bleu ne croise pas le polygone A car l'intersection entre ces deux géométries est égale au trait bleu. De plus, les polygones A et B ne se croisent pas non plus car leur intersection forme un polygone. Un polygone a une dimension géométrique de 2, tout comme les polygones A et B. Ainsi, seul le trait mauve croise le polygone A. En effet, une partie seulement de sa géométrie intersecte le polygone A, le reste étant situé à l'extérieur du polygone.


####### La fonction `st_overlaps` {-}

La fonction `st_overlaps()` vérifie si l'intersection entre deux géométries de même dimension possède aussi la même dimension. De plus, cette intersection ne peut être égale à une des deux géométries interrogées. La figure \@ref(fig:st-overlaps) illustre différentes combinaisons de géométries qui satisfont à la condition de superposition.

```{r st-overlaps, fig.align='center', echo=FALSE, fig.cap="Combinaisons de géométries qui se superposent. Image récupérée sur le site de documentation de **postgis**: http://postgis.net/workshops/postgis-intro/spatial_relationships.html", out.width = '60%'}
knitr::include_graphics('Module7/images/st_overlaps.png')
```

Considérons les polygones A, B, ainsi que celui de l'Abitibi-Témiscamingue illustrés à la figure \@ref(fig:st-geo-conf3). 

```{r st-geo-conf3, warning=FALSE, echo=FALSE, fig.align='center', dev = 'png',fig.cap="Exemples illustrant la fonction `st_overlaps()`.", out.width = '100%'}
map_AB <- mapview(A, col.regions = "blue", alpha.regions = 0.2, legend = FALSE) + 
mapview(Abitibi, col.regions = "green", alpha.regions = 0.2, legend = FALSE) + 
    mapview(B, col.regions = "red", alpha.regions = 0.2, legend = FALSE) 
map_AB@map
```

<br>


Les polygones A et B satisfont la condition de superposition car leur intersection est aussi un polygone. Par ailleurs le polygone A et celui de l'Abitibi ne satisfont pas à la condition de superposition car l'intersection est identique au polygone de l'Abitibi-Témiscamingue. 

```{r}
st_overlaps(A,B)
st_overlaps(Abitibi,A)
```

####### La fonction `st_touches` {-}

La fonction `st_touches()` vérifie si deux objets `X` et `Y` ont au moins un point en commun sans toutefois que leurs interieurs s'intersectent. La figure \@ref(fig:st-touches) illustre différentes combinaisons de géométries qui se touchent.

```{r st-touches, fig.align='center', echo=FALSE, fig.cap="Combinaisons de géométries qui se touchent. Image récupérée sur le site de documentation de **postgis**: http://postgis.net/workshops/postgis-intro/spatial_relationships.html", out.width = '60%'}
knitr::include_graphics('Module7/images/st_touches.png')
```

Considérons par exemple les objets spatiaux illustrés à la figure \@ref(fig:st-geo-conf4) &nbsp;:

```{r st-geo-conf4, warning=FALSE, echo=FALSE, fig.align='center', dev = 'png',fig.cap="Exemples illustrant la fonction `st_touches()`", out.width = '100%'}
Mauricie <- subset(regions_nad, Rgns_Ad == "Mauricie")

map_AB <- mapview(A, col.regions = "blue", alpha.regions = 0.2, legend = FALSE) + 
  #mapview(A_trait, color = "black", lwd = 3, legend = FALSE) +
  mapview(B, col.regions = "red", alpha.regions = 0.2, legend = FALSE) +
  
  mapview(point_bleu, col.regions = "blue", legend = FALSE)+
  mapview(point_vert, col.regions = "darkgreen", legend = FALSE)+
    mapview(trait_mauve, color = "purple", lwd = 3, legend = FALSE)


mapreg<- mapview(Abitibi, col.regions = "green", alpha.regions = 0.2, legend = FALSE) + 
    mapview(Mauricie, col.regions = "yellow", alpha.regions = 0.2, legend = FALSE)

M <- leafsync::latticeView(map_AB, mapreg, ncol = 2)
M

```

<br>


La fonction `st_touches()` nous permet de vérifier que le polygone B, en rouge, touche au trait mauve et que le polygone A, en bleu, touche au point vert. Par ailleurs, la fonction confirme aussi que le polygone A ne touche pas au point bleu car ce sont leurs intérieurs qui s'intersectent. La même situation s'observe pour les polygones A et B qui partagent plus que leurs frontières. Cependant les polygones de l'Abitibi-Témiscamingue, en vert, et de la Mauricie, en jaune, s'intersectent seulement le long de leurs frontières et ainsi se touchent.

```{r, warning=FALSE}
st_touches(B, trait_mauve)
st_touches(A, point_vert)
st_touches(A, point_bleu)
st_touches(A,B)
st_touches(Abitibi,Mauricie)

```

####### Les fonctions `st_within`  et `st_contains` {-}

La fonction `st_within(X,Y)` vérifie si l'objet `X` est entièrement à l'intérieur de l'objet `Y`. À l'opposé, la fonction `st_contains(X,Y)` vérifie si l'objet `X` contient entièrement l'objet `Y`. L'ordre des arguments est donc important dans l'utilisation de ces deux fonctions.


La figure \@ref(fig:st-within) illustre différentes combinaisons de géométries qui sont contenues dans une autre géométrie.

```{r st-within, fig.align='center', echo=FALSE, fig.cap="Combinaisons de géométries qui contiennent ou sont contenues dans une autre géométrie. Image récupérée sur le site de documentation de **postgis**: http://postgis.net/workshops/postgis-intro/spatial_relationships.html", out.width = '60%'}
knitr::include_graphics('Module7/images/st_within.png')
```


```{r, warning = FALSE, echo = FALSE}
B_contour <- st_cast(B, to = "MULTILINESTRING")
contour_rose <- B_contour
B_points<-st_cast(B,to = "POINT")
B_sub<-B_points[40:90,]
B_trait <- st_combine(B_sub)
B_trait <-st_cast(B_trait, to = "LINESTRING", group_or_split = TRUE)

nouveau_trait_points<-st_union(B_sub[1,],point_jaune)
nouveau_trait<-st_cast(nouveau_trait_points, to = "LINESTRING")
trait_gros<-st_union(nouveau_trait, B_trait)
trait_vert<-trait_gros
```


Pour illustrer ces fonctions, considérons les objets spatiaux illustrés à la figure \@ref(fig:st-geo-conf5) &nbsp;:

```{r st-geo-conf5, warning=FALSE, echo=FALSE, fig.align='center', dev = 'png',fig.cap="Exemples illustrant les fonctions `st_contains()` et `st_within()`.", out.width = '100%'}
map_AB <- mapview(A, col.regions = "blue", alpha.regions = 0.2, legend = FALSE) + 
  mapview(B, col.regions = "red", alpha.regions = 0.2, legend = FALSE) +
  mapview(trait_bleu, color ="darkblue", lwd = 3, legend = FALSE)+
  mapview(point_bleu, col.regions = "blue", legend = FALSE)+
  mapview(contour_rose, color = "hotpink", lwd = 5, legend = FALSE)+
  mapview(trait_mauve, color = "purple", lwd = 3, legend = FALSE)+
  mapview(trait_vert, color = "seagreen", lwd = 3, legend = FALSE)

map_AB@map

```

<br>

La fonction `st_contains()` nous permet de vérifier que le polygone A, en bleu, contient le point bleu et le trait bleu. Par contre, le polygone A ne contient pas le trait mauve puisque ce dernier n'est pas entièrement à l'intérieur de A. De plus, le contour rose du polygone B contient entièrement le trait mauve. 


```{r}
st_contains(A, point_bleu)
st_contains(A, trait_bleu)
st_contains(A, trait_mauve)
st_contains(contour_rose, trait_mauve)
```

<br>

La fonction `st_contains()` comporte une subtilité qui peut être trompeuse. La condition `st_contains(X,Y)` est satisfaite, c'est-à-dire, l'object `X` contient l'objet `Y`, si et seulement si aucun points de `Y` se trouve à l'extérieur de `X`, et qu'au moins un point de `Y` se trouve à l'intérieur de `X`^[http://lin-ear-th-inking.blogspot.com/2007/06/subtleties-of-ogc-covers-spatial.html]. En particulier, ceci signifie qu'un polygone ne contient jamais sa frontière. Ainsi, dans l'illustration de la figure \@ref(fig:st-geo-conf5), le polygone B, en rouge, ne contient pas le contour rose. Le polygone B ne contient pas non plus le trait mauve. Cependant, il contient le trait vert car ce dernier comporte des points à l'intérieur du polygone B.

```{r}
st_contains(B, contour_rose)
st_contains(B, trait_mauve)
st_contains(B, trait_vert)
```

<br>

La fonction `st_contains()` vérifie exactement la condition inverse de la fonction `st_within()`&nbsp;: 

```{r}
st_within(point_bleu, A)
st_within(trait_bleu, A)
st_within(trait_mauve, A)
st_within(trait_mauve, contour_rose)
st_within(contour_rose, B)
st_within(trait_mauve, B)
st_within(trait_vert, B)
```



<div class="boite ico important gauche">

###### Terminons cette sous-section par une remarque importante: {-}

<br>

</div>


La fonction [`st_join()`](#fct_join), vue plus, qui permet de faire une jointure spatiale entre deux objets vectoriels s'appuie, par défaut, sur la fonction de confirmation `st_intersects()`. En effet, la fonction `st_join(x,y)` identifie la présence d'une intersection entre les éléments de `x` et de `y` puis assigne les attributs de `y` aux éléments de `x` qui satisfont cette condition d'intersection. Par aileurs, il est possible d'utiliser la fonction `st_join()` en utilisant d'autres opérations topologiques de confirmation que celle par défaut. En effet, il est possible de définir un troisième argument, `join`, pour préciser une autre opération comme `st_contains`, `st_touches`, `st_overlaps` etc. 


Donnons un exemple. Pour chaque régions administratives du Québec, déterminons les régions qui lui sont adjacentes. Il s'agit ici d'utiliser la fonction `st_join()` avec la condition `st_touches`&nbsp;:

```{r}
st_join(regions, regions, join = st_touches)
```

<br>

Cette fonction nous retourne un objet spatial composé de deux attributs. L'attribut de gauche, `Rgns_Ad.x` donne le nom de chaque polygone des régions administratives de `regions` alors que l'attribut de droite, `Rgns_Ad.y`, assigne à chacun de ces polygones, le nom d'une des régions administrives qui lui est voisine. Puisque chaque polygone possède plus d'une région voisine, leur nom et leur géométrie sont répétées pour chaque région voisine. 


##### Opérations de mesure {-}

Plusieurs fonctions de la bibliothèque `sf` permettent de calculer des mesures spatiales comme la distance, la superficie, ou la longueur. 

###### La fonction `st_distance()` {.unnumbered #fct_distance}

La fonction `st_distance()` retourne la distance euclidienne entre deux objets spatiaux. Par exemple, nous pouvons utiliser cette fonction pour calculer la distance entre deux points. Calculons la distance qui sépare la ville de La Pocatière, dont nous avons isolé les coordonnées plus haut, et la ville de Rimouski.


```{r}
# Isoler le point correspondant aux coordonnées de la ville 
# de Rimouski à partir du shapefile des villes du Québec
rimouski <- subset(villes, toponyme == "Rimouski")
# Transformer rimouski dans le même SCR d'unité métrique que la_poc
rimouski_nad <-  st_transform(rimouski, crs = 32198)
# Calculer la distance
distance_lapoc_rimou <- st_distance(la_poc_nad, rimouski_nad)
distance_lapoc_rimou
```

<br>
 
La distance calculée est de `r as.integer(distance_lapoc_rimou[1])`&nbsp;m, soit environ `as.integer(round(distance_lapoc_rimou[1]/1000))` km. Notez que nous avons calculé la distance géométrique et non la distance que l'odomètre d'une voiture calculerait en voyageant sur l'autoroute entre La Pocatière et Rimouski. 

Observez que la fonction `st_distance()` retourne aussi l'unité de mesure, ici des mètres. En effet, l'objet retourné par cette fonction est de classe `units`&nbsp;:

```{r}
class(distance_lapoc_rimou)
```

<br>

Nous pouvons également utiliser la fonction `st_distance()` pour calculer la distance entre plusieurs points. Par exemple, considérons le shapefile `villes` et calculons la distance qui sépare La Pocatière de chacune des villes du Québec.

```{r}
# Transformer le SRC de villes
villes_nad <- st_transform(villes, crs = 32198)
# Calculer les distances
distance_la_poc_villes <- st_distance(villes_nad, la_poc_nad)
# Assigner le nom des villes
rownames(distance_la_poc_villes) <- villes$toponyme
colnames(distance_la_poc_villes) <- "La Pocatière"
# Les premières entrées 
head(distance_la_poc_villes)
```

<br>

Ou encore, calculons la distance qui sépare chacune des villes du Québec &nbsp;:
```{r}
distance_villes_villes <- st_distance(villes_nad, villes_nad)
colnames(distance_villes_villes) <- villes$toponyme
rownames(distance_villes_villes) <- villes$toponyme
quelques_villes <- c(49, 154, 314, 549, 639)
distance_villes_villes[quelques_villes, quelques_villes]
```

<br>

Cette fois, la fonction `st_distance()` retourne une matrice pour laquelle chaque entrée correspond à la distance entre deux villes. Cette matrice est bien sûr symétrique et sa diagonale est nulle.


Nous pouvons aussi utiliser la fonction `st_distance()`pour calculer la distance entre un point et un polygone. Par exemple, calculons la distance entre le point correspondant au centre du polygone de l'Abitibi-Témiscamingue et le polygone du Saguenay - Lac-Saint-Jean (voir la figure \@ref(fig:centroid-regions)).

```{r}
st_distance(centre_Abitibi, SagStJean)
```

<br>

Notez que pour calculer la distance entre un polygone et un point, ce dernier doit être situé à l'extérieur du polygone, sans quoi cette fonction retourne la valeur zéro &nbsp;:

```{r}
st_distance(centre_Abitibi, Abitibi)
```

<br>

La distance entre deux polygones se calcule de façon similaire. 

```{r}
st_distance(Abitibi, SagStJean, by_element = TRUE)
```

<br>

Cette mesure correspond à la plus petite distance séparant les deux polygones.


###### La fonction `st_area()` {-}

La fonction `st_area()` calcule la superficie d'un polygone. Calculons par exemple la superficie des polygones illustrés à la figure \@ref(fig:st-geo-conf5))&nbsp;:


```{r}
st_area(A)
st_area(B)
st_area(inter_AB)
```

<br>

Remarquez que les unités, ici des mètres carrés, sont fournies. L'objet retourné par la fonction `st_area()` est aussi de classe `units`&nbsp;:

```{r}
class(st_area(A))
```

<br>

La superficie d'objets spatiaux de dimension inférieure à deux est bien nulle&nbsp;:

```{r}
st_area(point_bleu)
st_area(trait_bleu)
```


###### La fonction `st_length()` {.unnumbered #fct_length}

La fonction `st_length()` calcule la longueur d'un objet spatial unidimensionnel (`LINESTRING`, `MULTILINESTRING`). 

```{r}
st_length(trait_bleu)
st_length(trait_mauve)
st_length(contour_rose)
```

<br>

Comme pour les fonctions `st_distance()` et `st_area()`, la fonction `st_length()` retourne un objet de classe `units`.


La fonction calcule une longueur nulle pour les polygones ou les points&nbsp;:
```{r}
st_length(A)
st_length(point_bleu)
```

###### La fonction `set_units` {-}

Il peut être pratique de changer les unités de mesure avec lesquelles nous travaillons. Par exemple, utiliser les mètres carrés lorsque nous traitons de larges étendues peut être encombrant. La fonction `set_units` de la bibliothèque `units` permet de transformer les unités de mesure d'un objet ou d'en assigner à un objet sans unités.

Par exemple, pour les unités de longueur&nbsp;:
```{r}
library(units)
L_m <- st_length(trait_bleu)
L_km <- set_units(L_m,km)
L_miles <- set_units(L_m, miles)

L_m
L_km
L_miles
```

<br>

Et, pour les unités d'aire&nbsp;:
```{r}
A_m2 <- st_area(A)
A_km2 <- set_units(A_m2, km2)
A_ha <- set_units(A_m2, ha) # 1 hectare (ha) mesure 100 m x 100 m

A_m2
A_km2
A_ha
```



### Problématique à résoudre {#prob_mod7}

Maintenant que nous avons appris les opérations de base pour manipuler les données vectorielles, nous sommes en mesure de résoudre la problématique énoncée au début de cette leçon&nbsp;: 

>
> **Parmi les dix plus grandes villes du Québec, quelle est celle qui dispose du plus grand nombre de parcs nationaux dans un rayon de 70&nbsp;km&nbsp;? **
>

<br>

Les étapes de la démarche de résolution sont les suivantes:

>
> 1. Obtenir la taille de la population de chacune des municipalités.
> 2. Filtrer ces municipalités pour retenir les 10 municipalités ayant la taille de population la plus importante.
> 3. Lire la géodatabase du réseau de la SÉPAQ.
> 4. Tracer une zone tampon de 70&nbsp;km de rayon autour de chacune des dix plus grandes villes.
> 5. Pour chaque zone, compter le nombre de parcs présent dans la zone tampon de 70&nbsp;km.
> 6. Déterminer la ville qui compte le plus grand nombre de parcs dans la zone tampon qui lui est associée.
>

<br>

Commençons!

###### 1. Taille des populations pour chaque municipalité {-}

Nous devons obtenir la taille de la population de chacune des municipalités québécoises. Nous avons déjà réalisé cette opération lorsque nous avons appris à utiliser la fonction [`merge()`](#fct_merge). 

En effet, nous avons associé à chaque municipalité contenue dans le *shapefile* `villes` la taille de sa population telle que donnée dans le *dataframe* `pop`. Nous avons utilisé la fonction `merge()` sur les colonnes `toponyme` et `munnom` qui agissent comme dénominateur commun des deux jeux de données. Voici un rappel de l'opération exécutée&nbsp;:


```{r}
villes_pop <- merge(x = villes, y = pop, by.x="toponyme", by.y="munnom")
names(villes_pop)[2:3] <- c("superficie", "population") # Nous avions aussi changer le nom des colonnes!
head(villes_pop)
```

###### 2. Dix municipalités les plus grandes {-}

Nous devons filtrer l'objet `villes_pop` et sélectionner les 10 municipalités de plus grande population. Tout d'abord, il s'agit d'ordonner l'attribut `population` contenu dans l'objet `villes_pop`. Pour ce faire, nous allons utiliser la fonction `order()`:

```{r}
villes_pop <- villes_pop[order(villes_pop$population, decreasing = TRUE), ]
```
<br>

L'objet `villes_pop` est maintenant ordonné de manière décroissante en fonction de la taille de la population des municipalités. Ainsi, les 10 premières lignes de cet objet correspondent aux 10 municipalités les plus grandes du Québec. On peut donc assigner les 10 premières lignes à un nouvelle objet intitulé `top10_villes`:

```{r}
top10_villes <- villes_pop[1:10, ]
top10_villes
```
Visualisons ce nouvel objet avec la fonction `mapview()`.

```{r viz-top10-villes, dev = 'png'}
mapview(top10_villes, zcol= "population")
```

<br>

###### 3. Géodatabase du réseau de la SÉPAQ {-}

La troisième étape consiste à charger la couche d'informations spatiales contenant les différentes aires récréatives du Québec. Cette information se trouve à l'intérieur de la géodatabase `parcs.gdb` disponible dans le répertoire `Module7_donnees` que vous avez [téléchargé](#data_mod7) au début de la leçon.

Comme vu dans le [module 4](#vec), les géodatabase permettent de contenir plusieurs couches vectorielles. Nous devons donc lire la géodatabase et explorer les différentes couches afin de déterminer celle qui correspond aux aires récréatives.

```{r list-layers}
 
st_layers("Module7/Module7_donnees/parcs.gdb") 

```

Nous pouvons remarquer que les intitulés des différentes couches ne sont pas bien définis. Il faut donc prendre le temps de regarder la documentation accessible sur le site de [données ouvertes Québec](https://www.donneesquebec.ca/recherche/fr/dataset/couche-des-territoires-recreatifs-du-quebec-a-l-echelle-de-1-100-000/resource/229322ef-eca2-4ae9-a511-ba599bc2745e). Ne vous inquiétez pas, je l'ai fait pour vous! En s'intéressant à la structure de données et à la nomenclature utilisée et décrite, nous pouvons déterminer que la couche `terpnq_s` correspond aux territoires des parc nationaux du Québec. Nous pouvons donc faire la lecture de la géodatabase avec la fonction `st_read()` en précisant cette couche à l'aide de l'argument `layer`.

```{r load-parcs2}

parcs_nationaux <- st_read("Module7/Module7_donnees/parcs.gdb", layer = "terpnq_s") 

```
<br>

Visualisons les polygones de `parcs_nationaux`.

```{r vis-parcs, dev = 'png'}
mapview(parcs_nationaux, zcol = "TRQ_NM_TER", legend = FALSE)
```
<br>

Notez que l'attribut "TRQ_NM_TER" de l'objet `parcs_nationaux` correspond au nom de chaque parc national.
```{r}
parcs_nationaux$TRQ_NM_TER
```
<br>

###### 4. Zones tampons autour des plus grandes municipalités {-}

Nous traçons maintenant une zone tampon (`POLYGON`) de 70&nbsp;km de rayon autour de chaque municipalité (`POINT`) du *shapefile* `top10_villes`. Pour se faire, nous allons utiliser la fonction `st_buffer()`. Avant de réaliser cette opération, nous devons vérifier que le système de coordonnées de référence de l'objet spatial `top10_villes` est défini en unité métrique. En effet, la distance de 70&nbsp;km pourrait être interprétée comme étant 70&nbsp;degrés si l'unité de la projection était en degré. Attention, cette erreur est très courante! Lorsque l'on veut calculer des distances euclidiennes, il faut toujours s'assurer que l'unité du système de projection est en mètre et non en degré.

```{r crs-top-villes}
st_crs(top10_villes)$proj4string 
```
<br>

`+proj=longlat` atteste que la projection est en degré. Nous allons donc reprojeter l'objet `top10_villes` dans le système de coordonnées de référence NAD83 qui est métrique et dont le EPSG est 32198. NAD83 correspond au système de coordonnées *Conique conforme de Lambert*.

```{r transform-top-villes}
top10_villes_lcc <- st_transform(top10_villes, crs = 32198)
# On valide que les unités sont métriques (+units=m)
st_crs(top10_villes_lcc)$proj4string 
```
<br>

Traçons à présent les zones tampon (*buffer*) autour des municipalités à l'aide de la fonction `st_buffer()` comme expliqué précédemment, et visualisons le résultat de cette opération

```{r buffer-top-villes, dev = 'png'}
top10_villes_buffer <- st_buffer(top10_villes_lcc, dist = 70e3) # 70 kms en mètres = 70e3
mapview(top10_villes_buffer, zcol = "toponyme", legend = FALSE)
```

<br>

Rappelons que le premier argument de la fonction `st_buffer()` correspond à l'objet spatial à partir duquel nous créons les zones tampons, et le second argument correspond à la longueur du rayon des zones tampon en mètres (70&nbsp;km = 70e3&nbsp;m).


###### 5. Nombre de parcs dans chaque zone tampon {-}

Nous allons utiliser la fonction `st_intersects()` pour déterminer quels parcs de l'objet `parcs_nationaux` se trouvent, partiellement ou entièrement, à l'intérieur de chacune des zones tampons de l'objet `top10_villes_buffer`. Avant de réaliser cette opération spatiale, nous devons nous assurer que les deux objets spatiaux (`top10_villes_buffer` et `parcs_nationaux`) utilisent le même système de coordonnées de référence.

```{r interceptions-buffer-parcs}
st_crs(top10_villes_buffer) == st_crs(parcs_nationaux)
```
<br>

Puisque la réponse est négative, transformons le SCR de l'objet `parcs_nationaux`.
```{r}
parcs_nationaux_lcc = st_transform(parcs_nationaux, crs = st_crs(top10_villes_buffer))
```
<br>

Nous pouvons maintenant utiliser la fonction `st_intersects()`:

```{r}
st_intersects(x = top10_villes_buffer, y = parcs_nationaux_lcc, sparse = FALSE) 
```

<br>

La fonction `st_intersects` avec l'argument `sparse = FALSE` retourne une matrice avec en ligne les zones tampons des 10 plus grandes villes (argument `x` ci-dessus) et en colonne, les 27 parcs nationaux du Québec (argument `y` ci-dessus). Pour chacune des combinaisons, la valeur boléenne renvoyée (`TRUE` ou `FALSE`) spécifie si les deux polygones se chevauchent (partiellement ou non). 

L'une des propriétés intéressante des valeurs boléennes (`TRUE` ou `FALSE`), renvoyées par la fonction `st_intersects`, est que la valeur `TRUE` peut être interprétée par `R` comme une valeur de 1 et `FALSE` comme une valeur de 0. Il est donc possible de réaliser des opérations mathématiques sur des valeurs boléennes. 

Par exemple, nous pouvons effectuer une sommation sur les lignes (zones tampons de chaque grande municipalité) afin de déterminer combien de parcs nationaux se trouvent à l'intérieur des zones tampons (c-à-d combien d'éléments ont la valeur `TRUE`).

```{r top-villes-parcs}
rowSums(st_intersects(x = top10_villes_buffer, y = parcs_nationaux_lcc, sparse = FALSE))
```
<br>

Consignons à présent ces valeurs dans une nouvelle colonne de la table d'attributs de l'objet `top10_villes`.

```{r top-villes-parcs2}
top10_villes$nbr_parcs <- rowSums(st_intersects(x = top10_villes_buffer, y = parcs_nationaux_lcc, sparse = FALSE))

top10_villes
```
<br>


###### 7. Ville qui compte le plus grand nombre de parcs {-}

Pour répondre à la question posée, ordonnons la table d'attributs de l'objet `top10_villes` en se basant sur la nouvelle colonne `nbr_parcs`. 

```{r top-villes-parcs3}
top10_villes <- top10_villes[order(top10_villes$nbr_parcs, decreasing = TRUE), ]
top10_villes
```

<br>

Nous constatons que Sherbrooke *et* Saint-Jean-sur-Richelieu disposent toutes deux du plus grand nombre (4) de parcs nationaux dans un rayon de 70&nbsp;km!



## Exercices {#ex_map_vec}

Dans cette section, vous mettrez en pratique certains concepts vus dans la section [leçon](#lecon_manip_vec) de ce module.
Bien que la réponse à chaque question soit disponible, il est **très important** de tenter d'y répondre par vous même!

<br>

```{r, echo=FALSE, eval=TRUE}
library(sf)
library(mapview)
library(units)
```


### Question 1 {-}

**a)** Construire un polygone de la forme d'un quadrilatère dont les sommets correspondent aux municipalités suivantes: Blanc-Sablon, Gaspé, Ivujivik et Chisasibi.


<details>
<summary> Réponse</summary>
<p>

Utiliser la fonction `subset()` pour filtrer le *shapefile* `municipalites` et isoler ces quatres villes.

```{r, warning = FALSE}
Selection <- subset(villes, (toponyme == "Blanc-Sablon") | 
                      (toponyme == "Gaspé") | 
                      (toponyme == "Ivujivik") | 
                      (toponyme == "Chisasibi"))

Selection
```
<br>

Le symbole `|` signifie *et*.

Combiner ces quatres villes (points) en un seul objet spatial (multipoints) en utilisant la fonction `st_combine()`&nbsp;:

```{r}
Combo_Selection <- st_combine(Selection)
Combo_Selection
```
<br>

Transformer cet objet multipoints en polygone en utilisant la fonction `st_cast()`&nbsp;:

```{r, warning = FALSE}
Poly_Selection <- st_cast(Combo_Selection, to = "POLYGON")
Poly_Selection
```
<br>

Confirmer votre réponse en visualisant le polygone formé&nbsp;:

```{r, warning = FALSE, dev = 'png'}
mapview(Poly_Selection)

```
<br>



</p>
</details> 

<br>

**b)** Quelle est la superficie, en km, de ce polygone?

<details>
<summary> Réponse</summary>
<p>

S'assurer d'abord que le polygone est représenté dans une projection métrique&nbsp;:

```{r, warning = FALSE}
st_crs(Poly_Selection)$proj4string 
```
<br>

`+proj=longlat` atteste que la projection est en degré. Reprojeter l'objet dans le SCR NAD83 dont le EPSG est 32198&nbsp;:

```{r, warning = FALSE}
Poly_Selection_nad83 <- st_transform(Poly_Selection, crs = 32198)
st_crs(Poly_Selection_nad83)$proj4string 
```
<br>

Les unités sont à présent en mètres.

Calculer la superficie du polygone en utilisant la fonction `st_area()` et convertisser les unités en $km^2$ en utilisant la fonction `set_units()`&nbsp;:

```{r, warning = FALSE}
Aire <- st_area(Poly_Selection_nad83)
Aire_km2 <- set_units(Aire, km2)
Aire_km2
```
<br>

</p>
</details> 

<br>

### Question 2 {-}

**a)** Combien de villes se trouvent dans une zone tampon de 20 km autour de la frontière séparant les régions administratives des Laurentides et de Lanaudière.

<details>
<summary> Réponse</summary>
<p>

Utiliser la fonction `subset()` pour filtrer le *shapefile* `regions` et isoler les polygones correspondants aux Laurentides et à Lanaudière.

```{r, warning = FALSE}
regions_nad <- st_transform(regions, crs = 32198) #utiliser une projection métrique
Laurentides <- subset(regions_nad, Rgns_Ad == "Laurentides")
Lanaudiere <- subset(regions_nad, Rgns_Ad == "Lanaudière")
```
<br>

Trouver la frontière entre les deux régions en utilisant la fonction `st_intersection()`&nbsp;:

```{r, warning = FALSE, dev = 'png'}
Frontiere <- st_intersection(Laurentides, Lanaudiere)
mapview(Frontiere)
```
<br>

La visualisation permet de valider votre calcul.

Créer maintenant une zone tampon de 50 km autour de la frontière en utilisant la fonction `st_buffer`&nbsp;:

```{r, warning = FALSE, dev = 'png'}
Frontiere_tampon <- st_buffer(Frontiere, dist = 20e3)
mapview(Frontiere_tampon)
```
<br> 


Utiliser à nouveau la fonction `st_intersection()` pour trouver les municipalités à l'intérieur de la zone tampon. Il s'agit, en effet, de trouver l'intersection entre les *shapeliles* `villes` et `Frontiere_tampon`.

```{r, warning = FALSE, dev = 'png'}
villes_nad <- st_transform(villes, crs = 32198) #utiliser une projection métrique
Villes_Frontiere_tampon <- st_intersection(villes_nad, Frontiere_tampon)
mapview(Villes_Frontiere_tampon)
```
<br>

Utiliser la fonction `nrow()` pour trouver le nombre de villes dans la zone tampon.

```{r, warning=FALSE}
nrow(Villes_Frontiere_tampon)
```
<br>

</p>
</details> 

<br>

**b)** Calculer la taille de la population qui habite cette zone tampon.


<details>
<summary> Réponse</summary>
<p>


Utiliser la fonction `merge()` pour combiner le tableau `pop` listant la taille des populations municipales à l'objet `Villes_Frontiere_tampon` défini plus haut.

```{r, warning=FALSE}
Villes_Frontiere_tampon_pop <- merge(x = Villes_Frontiere_tampon, y = pop, by.x = "toponyme", by.y = "munnom" )
head(Villes_Frontiere_tampon_pop)
```
<br>

Utiliser la fonction `sum()` pour calculer la population totale comprise dans la zone tampon.

```{r, warning=FALSE}
sum(Villes_Frontiere_tampon_pop$mpopul)
```
Une autre façon d'obtenir le même résultat est d'utiliser la fonction `aggregate()`&nbsp;:

```{r, warning=FALSE}
villes_nad_pop <- merge(x = villes_nad, y = pop, by.x = "toponyme", by.y = "munnom" )
aggregate(villes_nad_pop["mpopul"], by = Frontiere_tampon, FUN = sum)
```


</p>
</details> 

<br>



### Question 3 {-}

Trouver les régions administratives traversées par la ligne reliant la ville de Sherbrooke à celle de Fermont.
<br>

<details>
<summary> Réponse</summary>
<p>

<br>
Utiliser la fonction `subset()` pour isoler les points du *shapefile* `villes_nad` correspondants aux villes de Sherbrooke et de Fermont.

```{r, warning = FALSE, dev = 'png'}
Sherb_Fermont <- subset(villes_nad, (toponyme == "Sherbrooke") | (toponyme == "Fermont"))

mapview(Sherb_Fermont) 
```
<br>

Utiliser la fonction `st_combine()` pour combiner ces deux points en une seule géométrie multipoint.

```{r, warning=FALSE}
Sherb_Fermont_points <- st_combine(Sherb_Fermont)
```

<br>

Utiliser la fonction `st_cast()` pour transformer la géométrie multipoint en ligne.

```{r, warning=FALSE, dev = 'png'}
Sherb_Fermont_ligne <- st_cast(Sherb_Fermont_points, to = "LINESTRING")

mapview(Sherb_Fermont_ligne)
```
<br>

Utiliser maintenant la fonction `st_crosses` pour déterminer les régions administratives traversées par cette ligne.

```{r, warning=FALSE}
regions_nad[st_crosses(regions_nad, Sherb_Fermont_ligne, sparse = FALSE ),]
```
<br>

Utiliser la fonction `mapview()` pour valider visuellement votre réponse.

```{r, warning=FALSE, dev = 'png'}
regions_traversees <- regions_nad[st_crosses(regions_nad, Sherb_Fermont_ligne, sparse = FALSE ),]

mapview(regions_traversees) + mapview(Sherb_Fermont_ligne)

```
<br>


</p>
</details> 

<br>

### Question 4 {-}

La [problématique](#prob_mod7) résolue à la fin de la leçon, nous a permis de déterminer que 4 parcs de la SÉPAQ se trouvent dans un rayon de 70&nbsp;km de la municipalité de Saint-Jean-sur-Richelieu. Quelle est la superficie totale couverte par ces parcs à l'intérieur de ce rayon ?

<details>
<summary> Réponse</summary>
<p>

À partir de l'objet spatial `top10_villes_buffer` créé plus tôt, isoler la zone tampon autour de la municipalité de Saint-Jean-sur-Richelieu en utilisant la fonction `subset()`.

```{r, warning=FALSE}
SJSR_tampon <- subset(top10_villes_buffer, toponyme == "Saint-Jean-sur-Richelieu")
```

<br>

Utiliser la fonction `st_intersection` pour trouver les parcs du *shapefile* `parcs_nationaux_lcc` qui intersectent cette zone tampon.

```{r, warning = FALSE, dev = 'png'}
Parcs_SJSR_tampon <- st_intersection(parcs_nationaux_lcc, SJSR_tampon)

mapview(Parcs_SJSR_tampon) + mapview(SJSR_tampon, col.regions = "red", alpha.regions = 0.2)

```
<br>

Utiliser la fonction `st_area()` pour déterminer la superficie de chacun des parcs.

```{r, warning=FALSE}
Aire_Parcs_SJSR_tampon <- st_area(Parcs_SJSR_tampon)
Aire_Parcs_SJSR_tampon
```
<br>

Utiliser la fonction `sum()` pour déterminer la superficie totale, puis la fonction `set_units()` pour transformer les mètres carrés en hectares.

```{r, warning=FALSE}
AireTot_Parcs_SJSR_tampon <- sum(Aire_Parcs_SJSR_tampon)
AireTot_Parcs_SJSR_tampon <- set_units(AireTot_Parcs_SJSR_tampon, ha)
AireTot_Parcs_SJSR_tampon
```
<br>


</p>
</details> 
